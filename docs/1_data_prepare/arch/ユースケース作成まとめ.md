# 概要

データベースに実データを挿入するユースケースの作成の手順をここに残す。

# 最終目標

- (*ctx* context.Context, *cardInfo* carddto.StandardCard) を引数として、データベースの適切なテーブルに適切な値を挿入する

```go
type StandardCard struct {
	DescEn         string   `json:"descEn"`
	DescJa         string   `json:"descJa"`
	NameEn         string   `json:"nameEn"`
	NameJa         string   `json:"nameJa"`
	NeuronID       int64    `json:"neuronId"`
	TcgID          int64    `json:"tcgId"`
	Def            int64    `json:"def"`
	Atk            int64    `json:"atk"`
	Type           string   `json:"type"`
	Level          int64    `json:"level"`
	Race           string   `json:"race"`
	LinkMarkers    []string `json:"linkMarkers"`
	Attribute      string   `json:"attribute"`
	LinkVal        int64    `json:"linkVal"`
	TypeLines      []string `json:"typeLines"`
	CardType       string   `json:"cardType"`
	PendulumTextJa string   `json:"pendulumTextJa"`
	PendulumTextEn string   `json:"pendulumTextEn"`
}
```

# 手順（魔法・罠に限定）

Card: SQLクエリの作成

Type: SQLクエリの作成

config.test_data.goにおけるtrunCateSQLの修正

カード種別固有のSelectResultの準備

Card: エンティティに単純に挿入するリポジトリとテスト

Enumから単純に取得するリポジトリとそのテスト

UseCaseのテストを記述

UseCaseに処理を実装

# 手順詳細

## Card: SQLクエリの作成

検証することを考えると、SelectとInsertの2つが必要

SelectFullTrapCardInfoByCardIDのクエリを書いておくことで、後続の処理が楽になる

例

```go
-- name: FindTrapByCardID :one
-- FindTrapByCardID ...
SELECT card_id, trap_type_id
FROM traps
WHERE card_id = $1;

-- name: InsertTrap :one
-- InsertTrap ...
INSERT INTO traps (card_id, trap_type_id)
VALUES ($1, $2)
RETURNING *;

-- name: SelectFullTrapCardInfoByNeuronID :one
-- GetTrapCardByNeuronID ...
SELECT 
  cards.*
  , trap_types.name_ja as trap_type_name_ja
  , trap_types.name_en as trap_type_name_en
  FROM cards
join traps on cards.id = traps.card_id
join trap_types on traps.trap_type_id = trap_types.id
WHERE cards.neuron_id = $1;

-- name: SelectFullTrapCardInfoByOcgApiID :one
-- GetTrapCardByyOcgApiID ...
SELECT 
  cards.*
  , trap_types.name_ja as trap_type_name_ja
  , trap_types.name_en as trap_type_name_en
  FROM cards
join traps on cards.id = traps.card_id
join trap_types on traps.trap_type_id = trap_types.id
WHERE cards.ocg_api_id = $1;

-- name: SelectFullTrapCardInfoByCardID :one
-- GetTrapCardByyOcgApiID ...
SELECT 
  cards.*
  , trap_types.name_ja as trap_type_name_ja
  , trap_types.name_en as trap_type_name_en
  FROM cards
join traps on cards.id = traps.card_id
join trap_types on traps.trap_type_id = trap_types.id
WHERE cards.id = $1;
```

## TypeEnum用のクエリを作成

例：こちらは名前から検索できればOK

```go
-- name: SelectTrapTypesByNameEn :one
-- SelectTrapTypesByNameEn ...
SELECT id, name_ja, name_en
FROM trap_types
WHERE name_en = $1;

-- name: SelectTrapTypesByNameJa :one
-- SelectTrapTypesByNameJa ...
SELECT id, name_ja, name_en
FROM trap_types
WHERE name_ja = $1;

-- name: SelectTrapTypesById :one
-- SelectTrapTypesById ...
SELECT id, name_ja, name_en
FROM trap_types
WHERE id = $1;

```

## sqlc_generate

code/cardApiCall/infoInser

```go
$ cd $(prjDir)/code/cardApiCall/infoInsert
$ sqlc generate
```

## config.test_data.goにおけるtrunCateSQLの修正

```go

```

## カード種別固有のSelectResultの準備

infoInsert/dto/carddtoの中に、「魔法」や「罠」に応じたDTO定義を準備する・

この際、carddto.goに書かれた定義を

```go
package carddto

import (
	"database/sql"

	"atomisu.com/ocg-statics/infoInsert/dto"
)

type TrapCardSelectResult struct {
	AbstractCardSelectResult
	TrapTypeNameJa string `db:"trap_type_name_ja" json:"trapTypeNameJa"`
	TrapTypeNameEn string `db:"trap_type_name_en" json:"trapTypeNameEn"`
}

type SelectFullTrapCardInfoRow struct {
	ID              int64          `db:"id" json:"id"`
	NeuronID        sql.NullInt64  `db:"neuron_id" json:"neuronId"`
	OcgApiID        sql.NullInt64  `db:"ocg_api_id" json:"ocgApiId"`
	NameJa          sql.NullString `db:"name_ja" json:"nameJa"`
	NameEn          sql.NullString `db:"name_en" json:"nameEn"`
	CardTextJa      sql.NullString `db:"card_text_ja" json:"cardTextJa"`
	CardTextEn      sql.NullString `db:"card_text_en" json:"cardTextEn"`
	Dataowner       sql.NullString `db:"dataowner" json:"dataowner"`
	RegistDate      sql.NullTime   `db:"regist_date" json:"registDate"`
	EnableStartDate sql.NullTime   `db:"enable_start_date" json:"enableStartDate"`
	EnableEndDate   sql.NullTime   `db:"enable_end_date" json:"enableEndDate"`
	Version         sql.NullInt64  `db:"version" json:"version"`
	TrapTypeNameJa  sql.NullString `db:"trap_type_name_ja" json:"trapTypeNameJa"`
	TrapTypeNameEn  sql.NullString `db:"trap_type_name_en" json:"trapTypeNameEn"`
}

func (t *TrapCardSelectResult) FromSelectFullTrapCardInfoRow(row SelectFullTrapCardInfoRow) *TrapCardSelectResult {
	return &TrapCardSelectResult{
		AbstractCardSelectResult: AbstractCardSelectResult{
			AbstractSelectResult: dto.AbstractSelectResult{
				ID:              row.ID,
				Dataowner:       row.Dataowner.String,
				RegistDate:      row.RegistDate.Time,
				EnableStartDate: row.EnableStartDate.Time,
				EnableEndDate:   row.EnableEndDate.Time,
				Version:         row.Version.Int64,
			},
			NeuronID:   row.NeuronID.Int64,
			OcgApiID:   row.OcgApiID.Int64,
			NameJa:     row.NameJa.String,
			NameEn:     row.NameEn.String,
			CardTextJa: row.CardTextJa.String,
			CardTextEn: row.CardTextEn.String,
		},
		TrapTypeNameJa: row.TrapTypeNameJa.String,
		TrapTypeNameEn: row.TrapTypeNameEn.String,
	}
}

```

## Card: エンティティに単純に挿入するリポジトリとテスト

テストも記載する。雰囲気などについては既存のプロジェクトを確認すること

### リポジトリのコード

```go
package repository

import (
	"context"
	"database/sql"
	"time"

	"atomisu.com/ocg-statics/infoInsert/dto/carddto"
	"atomisu.com/ocg-statics/infoInsert/sqlc_gen"
	"go.uber.org/zap"
)

// TrapRepository defines the interface for trap card database operations.
type TrapRepository interface {
	Repository
	GetTrapByCardID(ctx context.Context, cardId int64) (carddto.TrapCardSelectResult, error)
	InsertTrap(ctx context.Context, cardId int64, trapTypeId int32) (sqlc_gen.Trap, error)
}

type trapRepositoryImpl struct {
	*repository
	queries *sqlc_gen.Queries
}

// NewTrapRepository creates a new instance of TrapRepository.
func NewTrapRepository(q *sqlc_gen.Queries) TrapRepository {
	return NewRepository(func(r *repository) TrapRepository {
		return &trapRepositoryImpl{
			repository: r,
			queries:    q,
		}
	})
}

// GetTrapByCardID retrieves a trap card by its card ID.
func (r *trapRepositoryImpl) GetTrapByCardID(ctx context.Context, cardId int64) (carddto.TrapCardSelectResult, error) {
	start := time.Now()
	defer r.logDBOperation("GetTrapByCardID", start, zap.Int64("card_id", cardId))

	trap, err := r.queries.SelectFullTrapCardInfoByCardID(ctx, cardId)
	if err != nil {
		r.logDBError("GetTrapByCardID", err, zap.Int64("card_id", cardId))
		return carddto.TrapCardSelectResult{}, err
	}
	var result carddto.TrapCardSelectResult
	result = *result.FromSelectFullTrapCardInfoRow(carddto.SelectFullTrapCardInfoRow(trap))
	r.logDBResult("GetTrapByCardID", result, zap.Int64("card_id", cardId))
	return result, nil
}

// InsertTrap inserts a new trap card into the database.
func (r *trapRepositoryImpl) InsertTrap(ctx context.Context, cardId int64, trapTypeId int32) (sqlc_gen.Trap, error) {
	start := time.Now()
	defer r.logDBOperation("InsertTrap", start, zap.Int64("card_id", cardId), zap.Int32("trap_type_id", trapTypeId))

	trap, err := r.queries.InsertTrap(ctx, sqlc_gen.InsertTrapParams{
		CardID:     cardId,
		TrapTypeID: sql.NullInt32{Int32: trapTypeId, Valid: true},
	})
	if err != nil {
		r.logDBError("InsertTrap", err, zap.Int64("card_id", cardId), zap.Int32("trap_type_id", trapTypeId))
		return sqlc_gen.Trap{}, err
	}

	r.logDBResult("InsertTrap", trap, zap.Int64("card_id", cardId), zap.Int32("trap_type_id", trapTypeId))
	return trap, nil
}

```

### テストコード

```go
package repository_test

import (
	"context"
	"fmt"
	"testing"

	"atomisu.com/ocg-statics/infoInsert/dto/carddto"
	"atomisu.com/ocg-statics/infoInsert/repository"
	"atomisu.com/ocg-statics/infoInsert/sqlc_gen"
	"atomisu.com/ocg-statics/infoInsert/transaction"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestForTrap tests the TrapRepository
func TestForTrap(t *testing.T) {

	t.Run("正常系01 トラップカードの新規登録処理", func(t *testing.T) {
		// セットアップ
		dbConn, card, cleanup := setupTest(t)
		defer cleanup()

		// Test data
		trapTypeID := int32(3) // カウンター罠のIDを便宜上セット

		// トランザクションの整備
		ctx := context.Background()
		tr := transaction.NewTx(dbConn.DB)

		// トランザクション境界の中で実行(useCaseではこの中にbaseCard挿入処理を入れる)
		var insertedTrap sqlc_gen.Trap
		err := tr.ExecTx(ctx, func(q *sqlc_gen.Queries) error {
			trapRepo := repository.NewTrapRepository(q)

			trap, err := trapRepo.InsertTrap(ctx, card.ID, trapTypeID)
			if err != nil {
				return fmt.Errorf("error inserting trap: %w", err)
			}
			insertedTrap = trap
			return nil
		})
		require.NoError(t, err, "Transaction should execute without error")

		// Verification
		assert.NotZero(t, insertedTrap.CardID, "Inserted trap should have a non-zero card ID")
		assert.Equal(t, trapTypeID, insertedTrap.TrapTypeID.Int32, "The trap's type ID should match the input")

		// データの取得
		ctx2 := context.Background()
		var fetchedTrap carddto.TrapCardSelectResult

		err = tr.ExecTx(ctx2, func(q *sqlc_gen.Queries) error {
			trapRepo := repository.NewTrapRepository(q)

			trap, err := trapRepo.GetTrapByCardID(ctx2, insertedTrap.CardID)
			if err != nil {
				return fmt.Errorf("error inserting trap: %w", err)
			}
			fetchedTrap = trap
			return nil
		})

		assert.Equal(t, insertedTrap.CardID, fetchedTrap.ID, "Fetched trap card ID should match the inserted one")
		assert.Equal(t, "カウンター", fetchedTrap.TrapTypeNameJa, "Fetched trap type ID should match the inserted one")
	})
}

```

## Enum(カード種別)から単純に取得するリポジトリとそのテスト

罠であれば、カウンターや永続などの種別が存在するので、それを取得するためのリポジトリを用意する。一応全パターン網羅するようテストコードを書くこと

### リポジトリそのもの

```go
package repository

import (
	"context"
	"database/sql"
	"time"

	"atomisu.com/ocg-statics/infoInsert/dto/kind"
	"atomisu.com/ocg-statics/infoInsert/sqlc_gen"
	"go.uber.org/zap"
)

// TrapTypeRepository defines the interface for trap type database operations.
type TrapTypeRepository interface {
	Repository
	GetTrapTypeByNameJa(ctx context.Context, nameJa string) (kind.TrapKind, error)
	GetTrapTypeByNameEn(ctx context.Context, nameEn string) (kind.TrapKind, error)
	GetTrapTypeById(ctx context.Context, id int32) (kind.TrapKind, error)
}

type trapTypeRepositoryImpl struct {
	*repository
	queries *sqlc_gen.Queries
}

// NewTrapTypeRepository creates a new instance of TrapTypeRepository.
func NewTrapTypeRepository(q *sqlc_gen.Queries) TrapTypeRepository {
	return NewRepository(func(r *repository) TrapTypeRepository {
		return &trapTypeRepositoryImpl{
			repository: r,
			queries:    q,
		}
	})
}

// GetTrapTypeByNameJa は和名で罠タイプを取得する
func (r *trapTypeRepositoryImpl) GetTrapTypeByNameJa(ctx context.Context, nameJa string) (kind.TrapKind, error) {
	start := time.Now()
	defer r.logDBOperation("GetTrapTypeByNameJa", start, zap.String("name_ja", nameJa))

	k := kind.TrapKind{}
	trapType, err := r.queries.SelectTrapTypesByNameJa(ctx, sql.NullString{String: nameJa, Valid: true})
	if err != nil {
		r.logDBError("GetTrapTypeByNameJa", err, zap.String("name_ja", nameJa))
		return k, err
	}

	row := kind.SelectFullKindInfoRow{
		ID:     trapType.ID,
		NameJa: trapType.NameJa,
		NameEn: trapType.NameEn,
	}

	return k.FromSelectFullKindInfoRow(row), nil
}

// GetTrapTypeByNameEn は英名で罠タイプを取得する
func (r *trapTypeRepositoryImpl) GetTrapTypeByNameEn(ctx context.Context, nameEn string) (kind.TrapKind, error) {
	start := time.Now()
	defer r.logDBOperation("GetTrapTypeByNameEn", start, zap.String("name_en", nameEn))

	k := kind.TrapKind{}
	trapType, err := r.queries.SelectTrapTypesByNameEn(ctx, sql.NullString{String: nameEn, Valid: true})
	if err != nil {
		r.logDBError("GetTrapTypeByNameEn", err, zap.String("name_en", nameEn))
		return k, err
	}

	row := kind.SelectFullKindInfoRow{
		ID:     trapType.ID,
		NameJa: trapType.NameJa,
		NameEn: trapType.NameEn,
	}

	return k.FromSelectFullKindInfoRow(row), nil
}

// GetTrapTypeById はIDで罠タイプを取得する
func (r *trapTypeRepositoryImpl) GetTrapTypeById(ctx context.Context, id int32) (kind.TrapKind, error) {
	start := time.Now()
	defer r.logDBOperation("GetTrapTypeById", start, zap.Int32("id", id))

	k := kind.TrapKind{}
	trapType, err := r.queries.SelectTrapTypesById(ctx, id)
	if err != nil {
		r.logDBError("GetTrapTypeById", err, zap.Int32("id", id))
		return k, err
	}

	row := kind.SelectFullKindInfoRow{
		ID:     trapType.ID,
		NameJa: trapType.NameJa,
		NameEn: trapType.NameEn,
	}

	return k.FromSelectFullKindInfoRow(row), nil
}

```

### テストコード

```go
package repository_test

import (
	"context"
	"fmt"
	"testing"

	"atomisu.com/ocg-statics/infoInsert/config"
	"atomisu.com/ocg-statics/infoInsert/dto/kind"
	"atomisu.com/ocg-statics/infoInsert/repository"
	"atomisu.com/ocg-statics/infoInsert/sqlc_gen"
	"atomisu.com/ocg-statics/infoInsert/transaction"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/assert"
)

// テスト用の共通処理
func testTrapTypeRetrieval(t *testing.T, dbConn *config.DbConn, target kind.TrapKind, getFunc func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error)) {
	ctx := context.Background()
	tr := transaction.NewTx(dbConn.DB)

	var result kind.TrapKind
	err := tr.ExecTx(ctx, func(q *sqlc_gen.Queries) error {
		trapTypeRepo := repository.NewTrapTypeRepository(q)
		trapType, err := getFunc(ctx, trapTypeRepo)
		if err != nil {
			return fmt.Errorf("error getting trap type: %w", err)
		}
		result = trapType
		return nil
	})

	assert.NoError(t, err)
	assert.Equal(t, target.ID, result.ID, "IDが一致しません")
	assert.Equal(t, target.NameJa, result.NameJa, "名前（和名）が一致しません")
	assert.Equal(t, target.NameEn, result.NameEn, "名前（英名）が一致しません")
}

// TestForTrap tests the TrapRepository
func TestForTrapType(t *testing.T) {

	t.Run("カウンター罠Enumの取得", func(t *testing.T) {
		target := kind.TrapTypeCounter

		// セットアップ
		dbConn, _, cleanup := setupTest(t)
		defer cleanup()

		// 和名で取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeByNameJa(ctx, target.NameJa)
		})

		// 英名で取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeByNameEn(ctx, target.NameEn)
		})

		// IDで取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeById(ctx, target.ID)
		})
	})

	t.Run("永続罠Enumの取得", func(t *testing.T) {
		target := kind.TrapTypeContinuous

		// セットアップ
		dbConn, _, cleanup := setupTest(t)
		defer cleanup()

		// 和名で取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeByNameJa(ctx, target.NameJa)
		})

		// 英名で取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeByNameEn(ctx, target.NameEn)
		})

		// IDで取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeById(ctx, target.ID)
		})
	})

	t.Run("通常罠Enumの取得", func(t *testing.T) {
		target := kind.TrapTypeNormal

		// セットアップ
		dbConn, _, cleanup := setupTest(t)
		defer cleanup()

		// 和名で取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeByNameJa(ctx, target.NameJa)
		})

		// 英名で取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeByNameEn(ctx, target.NameEn)
		})

		// IDで取得テスト
		testTrapTypeRetrieval(t, dbConn, target, func(ctx context.Context, repo repository.TrapTypeRepository) (kind.TrapKind, error) {
			return repo.GetTrapTypeById(ctx, target.ID)
		})
	})
}

```

## UseCaseのテストを記述

先にテストコードを準備しておく。罠であれば以下の通りである。

IDや名前などが一致する他、英語で表記されたRaceから日本語のタイプがきちんと導出されることを確認する

```go
// code/cardApiCall/infoInsert/usecase/neon_trap_test.go
package usecase_test

import (
	"context"
	"testing"

	"atomisu.com/ocg-statics/infoInsert/app"
	"atomisu.com/ocg-statics/infoInsert/config"
	"atomisu.com/ocg-statics/infoInsert/dto/carddto"
	"atomisu.com/ocg-statics/infoInsert/usecase"
	"github.com/samber/do"
	"github.com/stretchr/testify/assert"
)

func TestNeonUseCase(t *testing.T) {
	t.Parallel()

	t.Run("カード情報の挿入&取得テスト（カウンター罠）", func(t *testing.T) {
		sampleData := carddto.StandardCard{
			NameEn:   "Solemn Judgment",
			NameJa:   "神の宣告",
			DescEn:   "Sample Text.",
			DescJa:   "サンプルテキスト。",
			Type:     "Trap Card",
			NeuronID: 8916,
			TcgID:    41420027,
			Race:     "Counter",
		}

		config.BeforeEachForUnitTest()      // テスト前処理
		defer config.AfterEachForUnitTest() // テスト後処理

		injector := app.SetupDIContainer()
		do.Override(injector, config.TestDbConnection)

		neonUseCase := do.MustInvoke[usecase.NeonUseCase](injector)

		results, err := neonUseCase.InsertTrapCardInfo(context.Background(), sampleData)

		assert.NoError(t, err)
		assert.NotNil(t, results)

		results2, err := neonUseCase.GetTrapCardByID(context.Background(), results)
		assert.NoError(t, err)
		assert.NotNil(t, results2)
		assert.Equal(t, sampleData.NameEn, results2.NameEn)
		assert.Equal(t, sampleData.NameJa, results2.NameJa)
		assert.Equal(t, sampleData.DescEn, results2.CardTextEn)
		assert.Equal(t, sampleData.DescJa, results2.CardTextJa)
		assert.Equal(t, sampleData.NeuronID, results2.NeuronID)
		assert.Equal(t, sampleData.TcgID, results2.OcgApiID)
		assert.Equal(t, "カウンター", results2.TrapTypeNameJa)

	})

	t.Run("カード情報の挿入&取得テスト（永続罠）", func(t *testing.T) {
		sampleData := carddto.StandardCard{
			NameEn:   "Skill Drain",
			NameJa:   "スキルドレイン",
			DescEn:   "Sample Text.",
			DescJa:   "サンプルテキスト。",
			Type:     "Trap Card",
			NeuronID: 5740,
			TcgID:    82732705,
			Race:     "Continuous",
		}

		config.BeforeEachForUnitTest()      // テスト前処理
		defer config.AfterEachForUnitTest() // テスト後処理

		injector := app.SetupDIContainer()
		do.Override(injector, config.TestDbConnection)

		neonUseCase := do.MustInvoke[usecase.NeonUseCase](injector)

		results, err := neonUseCase.InsertTrapCardInfo(context.Background(), sampleData)

		assert.NoError(t, err)
		assert.NotNil(t, results)

		results2, err := neonUseCase.GetTrapCardByID(context.Background(), results)
		assert.NoError(t, err)
		assert.NotNil(t, results2)
		assert.Equal(t, sampleData.NameEn, results2.NameEn)
		assert.Equal(t, sampleData.NameJa, results2.NameJa)
		assert.Equal(t, sampleData.DescEn, results2.CardTextEn)
		assert.Equal(t, sampleData.DescJa, results2.CardTextJa)
		assert.Equal(t, sampleData.NeuronID, results2.NeuronID)
		assert.Equal(t, sampleData.TcgID, results2.OcgApiID)
		assert.Equal(t, "永続", results2.TrapTypeNameJa)

	})

	t.Run("カード情報の挿入&取得テスト（通常罠）", func(t *testing.T) {
		sampleData := carddto.StandardCard{
			NameEn:   "Welcome Labrynth",
			NameJa:   "ウェルカム・ラビュリンス",
			DescEn:   "Sample Text.",
			DescJa:   "サンプルテキスト。",
			Type:     "Trap Card",
			NeuronID: 17369,
			TcgID:    5380979,
			Race:     "Normal",
		}

		config.BeforeEachForUnitTest()      // テスト前処理
		defer config.AfterEachForUnitTest() // テスト後処理

		injector := app.SetupDIContainer()
		do.Override(injector, config.TestDbConnection)

		neonUseCase := do.MustInvoke[usecase.NeonUseCase](injector)

		results, err := neonUseCase.InsertTrapCardInfo(context.Background(), sampleData)

		assert.NoError(t, err)
		assert.NotNil(t, results)

		results2, err := neonUseCase.GetTrapCardByID(context.Background(), results)
		assert.NoError(t, err)
		assert.NotNil(t, results2)
		assert.Equal(t, sampleData.NameEn, results2.NameEn)
		assert.Equal(t, sampleData.NameJa, results2.NameJa)
		assert.Equal(t, sampleData.DescEn, results2.CardTextEn)
		assert.Equal(t, sampleData.DescJa, results2.CardTextJa)
		assert.Equal(t, sampleData.NeuronID, results2.NeuronID)
		assert.Equal(t, sampleData.TcgID, results2.OcgApiID)
		assert.Equal(t, "通常", results2.TrapTypeNameJa)

	})
}

```

## UseCase定義の修正

NeonUseCaseには、UseCase定義の他に、以下のメソッドが実装されていることが望ましい

1. InsertTrapCardInfo
2. GetTrapCardByID
3. InsertSpellCardInfo
4. GetSpellCardByID
5. InsertMonsterCardInfo
6. GetMonsterCardByID

```go
type NeonUseCase interface {
	UseCase
	InsertTrapCardInfo(ctx context.Context, cardInfo carddto.StandardCard) (int64, error)
	GetTrapCardByID(ctx context.Context, cardID int64) (carddto.TrapCardSelectResult, error)
}
```

## UseCaseの処理

基本的には１メソッドにつき、1トランザクション境界を張ることを徹底して欲しい。

やり方は以下の通りである。この状態でテストを通過することを確認して欲しい。

```go
package usecase

import (
	"context"
	"fmt"
	"strings"

	"atomisu.com/ocg-statics/infoInsert/dto/carddto"
	"atomisu.com/ocg-statics/infoInsert/repository"
	"atomisu.com/ocg-statics/infoInsert/sqlc_gen"
	"atomisu.com/ocg-statics/infoInsert/transaction"
)

func (n *neonUseCaseImpl) InsertTrapCardInfo(ctx context.Context, cardInfo carddto.StandardCard) (int64, error) {

	tr := transaction.NewTx(n.dbConn.DB)

	result := int64(0)

	// 一応のクレンジング処理
	race := strings.ToLower(strings.TrimSpace(cardInfo.Race))

	err := tr.ExecTx(ctx, func(q *sqlc_gen.Queries) error {
		// リポジトリの準備
		cardRepo := repository.NewCardRepository(q)
		trapRepo := repository.NewTrapRepository(q)
		trapTypeRepo := repository.NewTrapTypeRepository(q)

		// カードの挿入
		card, err := cardRepo.InsertCard(ctx, cardInfo.ToInsertCardParamsExceptMonster())
		if err != nil {
			return fmt.Errorf("error create card %w", err)
		}

		// トラップ種別の取得
		trapType, err := trapTypeRepo.GetTrapTypeByNameEn(ctx, race)
		if err != nil {
			return fmt.Errorf("error get trap type %w", err)
		}

		// Trapテーブルへの挿入
		_, err = trapRepo.InsertTrap(ctx, card.ID, trapType.ID)

		if err != nil {
			return fmt.Errorf("error create card %w", err)
		}

		result = card.ID
		return nil
	})

	return result, err
}

func (n *neonUseCaseImpl) GetTrapCardByID(ctx context.Context, cardID int64) (carddto.TrapCardSelectResult, error) {
	trapRepo := repository.NewTrapRepository(sqlc_gen.New(n.dbConn.DB))
	return trapRepo.GetTrapByCardID(ctx, cardID)
}

```

## UseCaseテストの通過

これがゴール

# 専門用語について

基本的には、以下のディレクトリにあるDMLを確認して欲しい
```
INSERT INTO spell_types (id, name_ja, name_en) VALUES
(1, '通常', 'Normal'),
(2, '永続', 'Continuous'),
(3, '装備', 'Equip'),
(4, 'フィールド', 'Field'),
(5, '速攻', 'Quick-Play'),
(6, '儀式', 'Ritual');

INSERT INTO trap_types (id, name_ja, name_en) VALUES
(1, '通常', 'Normal'),
(2, '永続', 'Continuous'),
(3, 'カウンター', 'Counter');

INSERT INTO monster_types (id, name_ja, name_en) VALUES
(1, '通常', 'Normal'),
(2, '効果', 'Effect'),
(3, 'トゥーン', 'Toon'),
(4, 'スピリット', 'Spirit'),
(5, 'ユニオン', 'Union'),
(6, 'デュアル', 'Dual'),
(7, 'チューナー', 'Tuner'),
(8, 'リバース', 'Reverse');

INSERT INTO races (id, name_ja, name_en) VALUES
(1, '魔法使い族', 'Spellcaster'),
(2, 'ドラゴン族', 'Dragon'),
(3, 'アンデット族', 'Zombie'),
(4, '戦士族', 'Warrior'),
(5, '獣戦士族', 'Beast-Warrior'),
(6, '獣族', 'Beast'),
(7, '鳥獣族', 'Winged Beast'),
(8, '悪魔族', 'Fiend'),
(9, '天使族', 'Fairy'),
(10, '昆虫族', 'Insect'),
(11, '恐竜族', 'Dinosaur'),
(12, '爬虫類族', 'Reptile'),
(13, '魚族', 'Fish'),
(14, '海竜族', 'Sea Serpent'),
(15, '水族', 'Aqua'),
(16, '炎族', 'Pyro'),
(17, '雷族', 'Thunder'),
(18, '岩石族', 'Rock'),
(19, '植物族', 'Plant'),
(20, '機械族', 'Machine'),
(21, 'サイキック族', 'Psychic'),
(22, '幻神獣族', 'Divine-Beast'),
(23, '幻竜族', 'Wyrm'),
(24, 'サイバース族', 'Cyberse'),
(25, '幻想魔族', 'Illusion');

INSERT INTO attributes (id, name_ja, name_en) VALUES
(1, '光', 'LIGHT'),
(2, '闇', 'DARK'),
(3, '地', 'EARTH'),
(4, '水', 'WATER'),
(5, '炎', 'FIRE'),
(6, '風', 'WIND'),
(7, '神', 'DIVINE');
```